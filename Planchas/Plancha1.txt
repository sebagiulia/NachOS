1)¿Por qué se prefiere emular una CPU en vez de utilizar directamente la CPU existente?
	
	Se prefiere emular una CPU en vez de utilizar directamente la CPU existente ya que permite un mayor
	control sobre los procesos que se ejecutan pudiendo depurar de forma mas profunda cada uno de estos.

2)¿Cuánta memoria tiene la máquina simulada para Nachos?
	
	PAGE_SIZE = SECTOR_SIZE = 128
	DEFAUL_NUM_PHYS_PAGES = 32
	MEMORY_SIZE = NUM_PHYS_PAGES * PAGE_SIZE = 32 * 128 = 3840 bytes

3)¿Qué modificaría para cambiar la cantidad de memoria?

	Para cambiar la cantidad de memoria cambiaría el número de paginas cuando llamo al constructor
	Machine::Machine(SingleStepper *st, unsigned aNumPhysicalPages);
	También se puede llamar a nachos con la opción -m, que modifica el número de páginas de la memoria.

4)¿De qué tamaño es un disco?

	SECTOR_SIZE = 128;       
	SECTORS_PER_TRACK = 32;                           
	NUM_TRACKS = 32;         
	NUM_SECTORS = SECTORS_PER_TRACK * NUM_TRACKS;
	DISK_SIZE = NUM_SECTORS * SECTOR_SIZE = 131,072 bytes

5)¿Cuántas instrucciones de MIPS simula la máquina virtual de Nachos?
	
	(encoding.hh)	   
    OP_ADD      =  1,
    OP_ADDI     =  2,
    OP_ADDIU    =  3,
    OP_ADDU     =  4,
    OP_AND      =  5,
    OP_ANDI     =  6,
    OP_BEQ      =  7,
    OP_BGEZ     =  8,
    OP_BGEZAL   =  9,
    OP_BGTZ     = 10,
    OP_BLEZ     = 11,
    OP_BLTZ     = 12,
    OP_BLTZAL   = 13,
    OP_BNE      = 14,
    OP_DIV      = 16,
    OP_DIVU     = 17,
    OP_J        = 18,
    OP_JAL      = 19,
    OP_JALR     = 20,
    OP_JR       = 21,
    OP_LB       = 22,
    OP_LBU      = 23,
    OP_LH       = 24,
    OP_LHU      = 25,
    OP_LUI      = 26,
    OP_LW       = 27,
    OP_LWL      = 28,
    OP_LWR      = 29,
    OP_MFHI     = 31,
    OP_MFLO     = 32,
    OP_MTHI     = 34,
    OP_MTLO     = 35,
    OP_MULT     = 36,
    OP_MULTU    = 37,
    OP_NOR      = 38,
    OP_OR       = 39,
    OP_ORI      = 40,
    OP_RFE      = 41,
    OP_SB       = 42,
    OP_SH       = 43,
    OP_SLL      = 44,
    OP_SLLV     = 45,
    OP_SLT      = 46,
    OP_SLTI     = 47,
    OP_SLTIU    = 48,
    OP_SLTU     = 49,
    OP_SRA      = 50,
    OP_SRAV     = 51,
    OP_SRL      = 52,
    OP_SRLV     = 53,
    OP_SUB      = 54,
    OP_SUBU     = 55,
    OP_SW       = 56,
    OP_SWL      = 57,
    OP_SWR      = 58,
    OP_XOR      = 59,
    OP_XORI     = 60,
    OP_SYSCALL  = 61,
    OP_UNIMP    = 62,
    OP_RES      = 63,
    MAX_OPCODE  = 63

6)¿En qué archivos está definida la función main? ¿En qué archivo está definida la función
main del ejecutable nachos del directorio userprog?
	
	La función main esta definida unicamente en la carpeta threads. El ejecutable que se compila desde
	userprog utiliza la función main definida en threads con la bandera de USER_PROGRAM activada.

7)¿Nombre los archivos fuente en los que figuran las funciones y métodos llamados por el
  main de Nachos al ejecutarlo en el directorio threads, hasta dos niveles de profundidad.
  Por ejemplo: main llama a Initialize, que está en tal archivo; e Initialize llama
  a ASSERT, que está en tal otro archivo.
	
	Initialize(system.cc) -> ASSERT(lib/assert.cc)
	DEBUG(lib/utility.hh) 
	SysInfo(threads/sys_info.cc)
	ThreadTest(threads/thread_test.cc)
	interrupt->Halt(machine/interrupt.cc)
	currentThread->Finish(threads/thread.cc)	

8)¿Qué efecto hacen las macros ASSERT y DEBUG definidas en lib/utility.hh?

ASSERT(condición): si la condición es falsa, imprime un mensaje mostrando la condición que falló, el archivo y la
línea en la que se encuentra, y lanza una excepción dump core.
DEBUG: si la bandera correspondiente de debug está activada, imprime la bandera seguida del mensaje.
Por ejemplo, si corremos ./nachos -d t
DEBUG('t', "Entering main\n"); imprimirá
[t] Entering main

9)Comente el efecto de las distintas banderas de depuración.

`+` -- Activa todas las banderas de depuración.
`t` -- Bandera de threads.
`s` -- Variables de condición, semáforos y locks.
`i` -- Interrupciones.
`m` -- Emulación del CPU (se requiere de *USER_PROGRAM*).
`d` -- Emulación del disco (requiere *FILESYS*).
`f` -- Bandera de File system (requiere *FILESYS*).
`a` -- Espacio de direcciones (requiere *USER_PROGRAM*).
`e` -- Manejo de excepciones (requiere *USER_PROGRAM*).


10)¿Dónde están definidas las constantes USER PROGRAM, FILESYS NEEDED, FILESYS STUB
   y NETWORK?
Están definidas en los Makefile de cada carpeta, según lo requerido.
USER_PROGRAM y FILESYS_NEEDED estan definidas en userprog/Makefile, vmem/Makefile y filesys/Makefile.
FILESYS STUB está definida en userprog/Makefile y vmem/Makefile.

11)¿Qué argumentos de línea de comandos admite Nachos? ¿Qué efecto tiene la opción -rs?
Los argumentos son:
Opciones generales:
	-d <debugflags> Enciende los mensajes de debug.
	-do <debugopts> debugopts: 
			    location: Cuando se imprime un mensaje de debug, se imprime también el archivo y
				      la línea donde se encuentra.
			    function: Cuando se imprime un mensaje de debug, también se imprime la función que lo llamó.
			    sleep: Llama a sleep 1 segundo luego de cada mensaje de debug.
			    interactive: Espera el input del usuario luego de cada mensaje de debug.

	-rs <random seed #> Hace que cada thread haga Yield a un tiempo aleatorio. Esta secuencia es replicable, ya que si 
			    llamamos al programa con la misma semilla, tendrá la misma secuencia. Esto nos permite
			    ejecutar nachos con aleatoriedad, pero pudiendo volver a ejecutar de la misma forma si es necesario.

	-z 		    Imprime la versión y la información de copyright.

	-m <num phys pages> Cantidad de páginas de memoria simulada.

Opciones para THREADS:
	-tt		    Permite elegir entre los test disponibles para ejecutar. 

	-tN 		    Ejecuta el test N.

Opciones para USER_PROGRAM:
	-s 		    El programa se ejecuta en modo paso a paso. 

	-x <nachos file>    Ejecuta un programa de usuario. 

	-tc <consoleIn> <consoleOut> Test de consola.

Opciones para FILESYS_:
	-f 		   Formatea el disco.
	-cp <unix file> <nachos file> Copia un archivo de UNIX a nachos.
	-pr <nachos file>  Imprime un archivo de nachos.
	-rm <nachos file>  Elimina un archivo de nachos.
	-ls 		   Lista los contenidos del directorio de nachos.
	-D 		   Imprime los contenidos de todo el file system.
	-c 		   Checkea la integridad del file system.
	-tf		   Checkea el rendimiento del file system.

12)Al ejecutar nachos -i, se obtiene información del sistema. Sin embargo está incom-
   pleta. Modifique el código para que se muestren los datos que faltan.

Realizamos las siguientes modificaciones en el archivo sys_info.cc:

-----------------------(agregamos este bloque de código al inicio)
#ifdef USER_PROGRAM
#include "system.hh"
#endif
-----------------------

----------------------------------------------------(agregamos el siguiente bloque de código encima del siguiente)
unsigned num_pages = DEFAULT_NUM_PHYS_PAGES;
#ifdef USER_PROGRAM
      num_pages = machine->GetNumPhysicalPages();
#endif    
----------------------------------------------------

-------------------------------------(modificamos las siguientes lineas de código)
    printf("\n\
Memory:\n\
  Page size: %d bytes.\n\
  Number of pages: %d.\n\
  Number of TLB entries: %d.\n\
  Memory size: %d bytes.\n", PAGE_SIZE, num_pages, TLB_SIZE, num_pages * PAGE_SIZE);

#include"../machine/disk.hh"
    printf("\n\
Disk:\n\
  Sector size: %d bytes.\n\
  Sectors per track: %d.\n\
  Number of tracks: %d.\n\
  Number of sectors: %d.\n\
  Disk size: %d bytes.\n", SECTOR_SIZE, SECTORS_PER_TRACK, NUM_TRACKS, NUM_SECTORS, NUM_SECTORS * SECTOR_SIZE);
    printf("\n\
Filesystem:\n\
  Sectors per header: %u.\n\
  Maximum file size: %u bytes.\n\
  File name maximum length: %u.\n\
  Free sectors map size: %u bytes.\n\
  Maximum number of dir-entries: %u.\n\
  Directory file size: %u bytes.\n",
      NUM_DIRECT, MAX_FILE_SIZE, FILE_NAME_MAX_LEN,
      FREE_MAP_FILE_SIZE, NUM_DIR_ENTRIES, DIRECTORY_FILE_SIZE);
}
------------------------------------------------------------------------------------------------------------------

13)¿Cuál es la diferencia entre las clases List y SynchList?

La diferencia es que SynchList es sincronizada, y List no. Esto significa que con SynchList sólo un thread puede
acceder a los objetos de la clase a la vez, evitando problemas de sincronización entre threads. SynchList tiene 
como objetos una lista de clase List, un lock y una variable de condición que indica si la lista está vacía. 
Si la lista está vacía mientras un thread quiere eliminar un elemento, el thread esperará hasta que no lo esté.

14)Modifique el caso de prueba simple del directorio threads para que se generen 5 hilos
   en lugar de 2.

----------------------------------------------------------------------------------------------(modificamos las siguientes lineas de código)
bool threads[4] = {false};
void
SimpleThread(void *name_)
{
    for (unsigned num = 0; num < 10; num++) {
        printf("*** Thread `%s` is running: iteration %u\n", currentThread->GetName(), num);
        currentThread->Yield();
    }
    if(!strcmp(currentThread->GetName(), "2nd")) threads[0] = true;
    else if(!strcmp(currentThread->GetName(), "3rd")) threads[1] = true;
    else if(!strcmp(currentThread->GetName(), "4th")) threads[2] = true;
    else if(!strcmp(currentThread->GetName(), "5th")) threads[3] = true;
    printf("!!! Thread `%s` has finished SimpleThread\n", currentThread->GetName());
 
}

void
ThreadTestSimple()
{
    Thread *newThread2 = new Thread("2nd");
    Thread *newThread3 = new Thread("3rd");
    Thread *newThread4 = new Thread("4th");
    Thread *newThread5 = new Thread("5th");
    newThread2->Fork(SimpleThread, NULL);
    newThread3->Fork(SimpleThread, NULL);
    newThread4->Fork(SimpleThread, NULL);
    newThread5->Fork(SimpleThread, NULL);

    //the "main" thread also executes the same function
    SimpleThread(NULL);

   //Wait for the threads to finish if needed
    while (!(threads[0] && threads[1] && threads[2] && threads[3])) {
        currentThread->Yield(); 
    }
    printf("Test finished\n");
}
--------------------------------------------------------------------------------------------------

15)Modifique el caso de prueba para que estos cinco hilos utilicen un semáforo inicializado
   en 3. Esto debe ocurrir solo si se define la macro de compilación SEMAPHORE TEST.

16)Agregue al caso anterior una línea de depuración que diga cuándo cada hilo hace un P()
   y cuándo un V(). La salida debe verse por pantalla solamente si se activa la bandera
   de depuración correspondiente.

17)En threads se provee un caso de prueba que implementa el jardín ornamental. Sin
   embargo, el resultado es erróneo. Corríjalo de forma que se mantengan los cambios de
   contexto, sin agregar nuevas variables.

18)Replique el jardín ornamental en un nuevo caso de prueba. Revierta la solución anterior
   y solucione el problema usando semáforos esta vez.


